---
title: 异步任务 + 消息队列
---

# celery 任务队列

# 理解 Rabbitmq

## rabbitmq 管理页面

![[WlHkbdGCSomrZGxGLo2cbbXbnqe.png]]

### 导航菜单

- <strong>Overview</strong>：总览，包含运行状态、消息速率、节点健康情况等。
- <strong>Connections</strong>：所有 TCP 连接（客户端应用连接 RabbitMQ）。
- <strong>Channels</strong>：连接内部开的逻辑通道（Connection 可以包含多个 Channel）。
- <strong>Exchanges</strong>：交换机，定义消息路由规则。展示了几种典型类型：

  - <strong>direct：</strong>点对点模式：根据 <strong>路由键 (routing key)</strong> 精确匹配，把消息投递到绑定了相同 routing key 的队列。
    👉 常用于任务分发、RPC 回复。
  - <strong>fanout</strong>
    广播模式：消息会投递到所有绑定的队列，<strong>忽略 routing key</strong>。
    👉 常用于事件通知、日志广播。
  - <strong>topic</strong>
    主题模式：根据 <strong>通配符匹配</strong>（`*` 和 `#`）路由键，把消息投递到匹配的队列。
    👉 常用于复杂的路由（如 `order.*`、`log.#`）。
  - <strong>headers</strong>
    头部模式：根据消息头属性匹配（不是 routing key）。
    👉 在实际业务里用得少。
- <strong>Queues and Streams</strong>：所有队列和流，展示消息堆积情况。
- <strong>Admin</strong>：用户、权限、策略等管理功能。

### 队列（Queues）

表格里的字段含义：

- <strong>Vhost：</strong>是虚拟主机的意思，专注于消息流转的隔离，它的作用是把 交换机 (exchange)、队列 (queue)、绑定 (binding)、权限 (permission) 分隔开，类似「数据库的库区间」。
- <strong>Name</strong>：队列名，比如 `celery`（是 celery 默认的消息队列名）
- <strong>Type</strong>：这里都是 `classic`（经典队列，RabbitMQ 默认类型）。
- <strong>Features</strong>：队列特征

  - D = Durable（持久化，RabbitMQ 重启后队列还在）
  - AD = Auto Delete（自动删除，连接断开后可能被删）
  - TTL Exp Args = 使用了 TTL（过期时间）、额外参数等。
- <strong>State</strong>：队列状态

  - idle = 空闲，没有正在消费
  - running = 有消费者订阅并活跃
- <strong>Ready</strong>：队列中等待被消费的消息数量
- <strong>Unacked</strong>：已经投递给消费者但还没确认 (ack) 的消息
- <strong>Total</strong>：消息总数（Ready + Unacked）
- <strong>incoming / deliver-get / ack</strong>：消息速率（每秒多少条）

  - incoming：生产者发进队列的速率
  - deliver/get：消息投递给消费者的速率
  - ack：消费者确认消息的速率

### 为什么有些队列是自动生成的？

是的，很多队列并不是你手动建的，而是由 <strong>框架或客户端库</strong> 自动声明的。
比如你页面里看到的：

- <strong>celery</strong><strong> 队列：</strong>业务任务队列，一般是你自己在 Celery 配置里指定的，特征是 <strong>D</strong>。根据业务手动建的任务队列，特征也是 <strong>D（持久化）</strong>
- <strong>celery@xxx.celery.pidboxmailto:celery@xxx.celery.pidbox</strong><strong> 队列：</strong>Celery worker 自动创建的 <strong>控制队列</strong>，用来收发 worker 控制命令（比如远程关停、ping、revoke task）。

  - 特征是 <strong>AD TTL Exp Args</strong>（自动删除 + 带过期设置），因为它是临时性的。
- <strong>celeryev.xxxxxxx</strong><strong> 队列：</strong>Celery <strong>事件队列</strong>，用来收集 worker 状态事件（任务开始、成功、失败等）。

  - 同样是 Celery 自动生成，带 <strong>AD TTL Exp Args</strong> 特征，且状态多为 `running`。

### connection 与 channal 的区别

![[UzQfb4ayRocZsdxE2kIcpEePnGc.png]]

## 消息 ACK 机制

ACK (Acknowledge character)，即是确认字符，消息的接收方需要告诉发送方已确认接收消息，这是实现可靠消息投递的必备特性。

![[PkuKbpZWpoNVGixo1slcu1ycnHh.png]]

本文链接： [https://www.itzhai.com/columns/mq/rabbitmq/features.html](https://www.itzhai.com/columns/mq/rabbitmq/features.html)

## 信息的生命周期

生产者发消息到交换机 → 交换机按规则路由到队列 → 队列再被消费者取走。

celery 专用的交换机，接收到消息后会将 Bindings 绑定的五个控制队列（一个自定义的队列对应一个事件队列）。

![[JP4gb5R2CopfNTxlki2cynMGngd.png]]

部署 flower 之后，多次一个事件队列，这是事件队列的消费者正是 flower。

![[DLoRbN7Ufo8FHaxSjAgcm3Wfnhg.png]]

# Celery 任务队列

## 解决 broker 挂掉时 celery 卡死的问题

在一个项目中用到了 celery，我们用 rabbitmq 来作为 broker，但是发现当 rabbitmq 挂掉时，celery 却无法发送任务，设计到 apply_async 和 delay 的代码会一直处在卡住的状态。

也尝试使用 celery 文档中的 BROKER_CONNECTION_TIMEOUT 参数，但不起效果，其实官方也说了：

The broker connection timeout only applies to a worker attempting to connect to the broker. It does not apply to producer sending a task, see broker_transport_options for how to provide a timeout for that situation.

这个参数仅对 worker 有用，对任务发送是无用的。很傲娇的是 `broker_transport_options` 这个链接中也未提供足够的帮助信息。

继续查找相关信息，在几个项目的 issue 页面看到些讨论，还是需要对 broker_transport_options 这个配置传入参数才行，例如：

```
BROKER_TRANSPORT_OPTIONS = {"max_retries": 3, "interval_start": 0, "interval_step": 0.2, "interval_max": 0.5}
```

这段配置意思为：

最多重试 3 次
从 0 秒开始重试
每次失败后等待 0.2 秒后再次进行尝试
总尝试时间不超过 0.5 秒

在项目中使用这个配置后发现确实解决了问题，代码在遇到 rabbitmq 挂掉的情况下不会再卡住了(因为都是用了 kombu，估计对 redis 作为 broker 也有效果吧)。

github 上的讨论的 issue 可见：[https://github.com/celery/celery/issues/4627#issuecomment-396907957](https://github.com/celery/celery/issues/4627#issuecomment-396907957)

# “吵闹邻居”的剖析

<strong>“Noisy Neighbor”（吵闹邻居）问题</strong>。在多租户系统中，一个贪婪的租户可能会饿死其他租户。

<u>如何解决队列的吵闹邻居问题</u>（英文）

如果有一个用户向队列提交了大量任务，会影响其他所有用户，这叫做"吵闹邻居问题"
